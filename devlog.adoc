= ANF devlog
:toc:
:toc-placement!:
:odin: https://github.com/odin-lang/Odin[Odin]
:zig: https://ziglang.org/[Zig]
:rust: https://www.rust-lang.org/[Rust]
:fna3d: https://github.com/FNA-XNA/FNA3D[FNA3D]
:fna: https://github.com/FNA-XNA/FNA[FNA]
:xna: https://en.wikipedia.org/wiki/Microsoft_XNA[XNA]
:sdl: https://www.sdl.com/[SDL]
:sokol: https://github.com/floooh/sokol[Sokol]
:fontstash: https://github.com/memononen/fontstash[fontstash]
:rust-sdl2: https://github.com/Rust-SDL2/rust-sdl2[Rust-SDL2]
:rust-fna3d: https://github.com/toyboot4e/rust-fna3d[Rust-FNA3D]
:soloud-rs: https://github.com/MoAlyousef/soloud-rs[soloud-rs]
:imgui-rs: https://github.com/Gekkio/imgui-rs[imgui-rs]
:learnopengl: https://learnopengl.com/[Learn OpenGL]
:ortho-mat: https://en.wikipedia.org/wiki/Orthographic_projection[orthographic projection matrix]

== Primer

=== What is ANF?

ANF is a 2D game framework in Rust. It's build on top of some C libraries.

* Why {rust}?
+
Because it's comfortable to me. There's no GC, there's a reliable build tool, there are good defaults such as `Result`, and there's always some answer to my question when I search about programming in Rust.
+
Rust force us borrow rules. I'm liking it, but it's not guaraneteed that it always works fine footnote:[Actually those intelligent people who moved me to make ANF framework were not interested in using Rust for their games. That's fair because they knew what they wanted to do and the borrow rules just bothered them.]. So someday I might want to switch to another language.

* Why making a framework?
+
For my fun. Also, this experience would be helpful for me when using other programming languages such as {zig} or {odin}.

* Why C libraries?
+
C has stable ABI and C can be used from almost any other programming language. I thought it's fascinating and I wanted to give it a try.

=== Dependent C libraries

* {sdl}: window creation and event handling
* {fna3d}: graphics
* {fontstash}: TTF handling
* {soloud-rs}: audio
* {imgui-rs}: developer UI

I made a wrapper of FNA3D myself. If you're interested in it, there's some https://github.com/toyboot4e/rust-fna3d/blob/master/docs/wrapping_c.md[note] on it.

== Devlog

=== Using FNA3D

I was new to graphics programming and {fna3d} was a bit hard for me. Before "kicking the rendering pipeline", I had to setup some properties of `Device` and it was not documented in `FNA3D.h`. So for long time I couldn't do other than clearing the screen.

I had to learn more. I read some chapters of {learnopengl} and got some vocabraries and ideas. Basic shaders are just about pixel mappings. GPU has special, fast memory for them and I can disose CPU side of textures after sending them to GPU. Makes sense!

I tried to learn from {fna}, but it was a total mistake. {fna} is an accurate re-implementing {xna} and it's not a comfortable code base to read through. So I learned from simpler frameworks by others that are using FNA3D.

Setting up {ortho-mat} was hard. FNA's looks like transposed from the one in Wiki. I asked about it and got answer: OpenGL uses column-major matrices while XNA uses row-major matrices. I thought it was about encoding (memory layout).. but it was not. When I searched about https://www.google.com/search?q=translation+matrix&client=safari&rls=en&source=lnms&tbm=isch&sa=X&ved=2ahUKEwiIm6aO1o_sAhUIPnAKHV1DB4UQ_AUoAXoECBMQAw&biw=1920&bih=1081&dpr=2[translation matrix], I saw two kinds of matrices. They're transposed and I was like "hey man which is correct". Then I realized that in "row-major" style position matrices are row vectors. OK, finally I got it.

=== Sokol

Other option to {fna3d} is {sokol}. {sokol} has beautiful API and it's becoming a fascinating option. But it's a bit harder to think about cross-platform compilation so I'm satisfies with {fna3d}.

